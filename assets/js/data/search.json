[ { "title": "SQL语法", "url": "/posts/SQL%E8%AF%AD%E6%B3%95/", "categories": "数据库", "tags": "技术", "date": "2022-04-10 06:07:00 +0000", "snippet": "数据库操作创建并使用数据库​create database Seejen;use seejen;创建表create table account( id int not null primary key, name varchar(50) not null, createTime date not null);修改表 添加列alter table accountadd money int; 删除列alter table accountdrop column createTime; 删除表drop table account;插入 插入一列insert into account values(1,&quot;MuQingci&quot;,1000); 将一个表插入一个新表create table newAccount as select * from account修改update account set name = &quot;Seejen&quot; where id =1;删除 删除某一行delete from account where id =1; 删除整张表truncate table account;查询Distinct相同的值只会出现一次。作用于 所有的列select distinct name from account;Limit限制返回的行数，可以有两个参数，第一个参数为起始行，从0开始，第二个参数表示返回的总行数。起始行为0可以省略。 返回前五行数据select * from account limit 5;select * from account limit 0,5; 返回第3-5行数据；select * from account limit 2,3;排序 ASC：升序（默认排序） DESC：降序可以按多个列进行排序，指定排序方式select * from account order by money desc,id asc;过滤数据的过滤可以使用where 子句，指定过滤条件where子句的操作符 操作符 作用 = 等于 &amp;lt; 大于 &amp;gt; 小于 &amp;lt;&amp;gt;!= 不等于 &amp;lt;=!&amp;gt; 小于等于 &amp;gt;=!&amp;lt; 大于等于 Between 两个值之间 is null 不为null and 和 or 用于连接多个过滤条件，优先处理and，当涉及多个and和or，可以使用()来指定优先级in 操作用于匹配一组值，后面可以接select语句，匹配子查询得到的一组值not操作符用于否定一个条件通配符通配符也是用在过滤语句中，但它只能用于文本字段 % 匹配大于等于0个字符 _ 匹配1个字符 []可以匹配集合内的字符，[ab]匹配a或b。^可以进行否定，不匹配集合内的字符。select * from account where name like &#39;z%&#39;;计算字段计算字段使用as来取别名，否则输出的时候字段名为计算表达式select col1*col2 as result from table;CONCAT()用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，可以使用TRIM()去除首尾空格。select concat(tirm(col1),&#39;(&#39;,trim(col2),&#39;)&#39;) as concat_col from table;函数MySQL的一些函数汇总 函数 作用 avg() 平均值 count() 某列的行数 max() 最大值 min() 最小值 sum() 某列值的和 注：AVG会忽略NULL行。文本处理 函数 作用 Left() 左边的字符 Right() 右边的字符 Lower() 转换为小写字符 Upper() 转换为大写字符 Lirim() 去除左边空格 Rtrim() 去除右边空格 Length() 长度 Sounded() 转换为语音值，可以找到读音近似的 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函数 作用 ADDDATE() 增加一个日期（天、周等） ADDTIME() 增加一个时间（时，分等） CURDATE() 返回当前日期 CURTIME() 当前时间 DATE() 返回日期时间的日期部分 DATEDIFF() 两个日期之差 DATE_ADD() 日期运算函数 DATE_FORMAT() 返回格式化日期或时间串 DAY() 返回日期的天数部分 DAYOFWEEK() 返回星期几 HOUR() 返回小时 MINUTE() 返回分钟 MONTH() 返回月 NOW() 返回当前日期和时间 SECOND() 返回时间的秒 TIME() 返回日期时间的时间部分 YEAR() 返回年份 select now();数值处理 函数 作用 sin() 正弦 cos() 余弦 tan() 正切 abs() 绝对值 Sqrt() 平方根 mod() 余数 Exp() 指数 pi() 圆周率 Rand() 随机数 分组分组把具有相同的数据值的行放在同一组中。可以对同一分组使用汇总函数进行处理，例如求分组的平均值等除了能够进行分组还能够按照字段排序select name,count(*) as numfrom accountgroup by name;select name,count(*) as numfrom accountgroup by nameorder by num;select name,count(*) as numfrom accountwhere money&amp;gt;=200group by namehaving num &amp;gt;=2;分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型子查询子查询中只能返回一个字段的数据。可以将子查询的结果作为where语句的过滤条件select * from account where name in (select name from orders);查询每个人的订单数量，子查询语句会对第一个查询检索出的每个人执行一次select account.name,(select count(*) from orders where orders.cust_id = account.id) as order_num from account order by account.name;连接组合查询视图存储过程游标触发器事务管理字符集权限管理" }, { "title": "Spring", "url": "/posts/Spring/", "categories": "Java框架", "tags": "技术", "date": "2022-04-08 14:20:00 +0000", "snippet": "" }, { "title": "数据结构", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/", "categories": "数据结构", "tags": "技术", "date": "2022-04-07 16:33:00 +0000", "snippet": "线性结构线性表及其基本操作线性表：由同类型数据元素构成的有序序列的线性结构，长度可以动态增长或收缩。 表中元素个数称为线性表 线性表没有元素时，成为空表 表起始位置称为表头，表结束位置称为表尾线性表的抽象数据类型描述两个要素： 数据对象集：线性表是n（&amp;gt;=0）个元素构成的有序序列（a1,a2,……） 操作集： clear() 将一个已存在的线性表置成空表 isEmpty() 判断线性表是否为空 length() 返回线性表长度 get(i) 读取线性表的第i个元素 insert(i,x) 在第i个元素之前插入一个值为x的元素，当i = length时，在表尾插入x remove(i) 删除并返回第i个元素 indexOf(x) 返回线性表中首次出现指定元素的序号，不包含返回-1 display() 出书线性表各个元素的值线性表的抽象数据Java接口：public interface Ilist{ public void clear(); public boolean isEmpty(); public int length(); public Object get(int i); public void insert(int i,Object x); public void remove(int i); public int indexOf(Object x); public void display();}线性表的顺序存储实现线性表的顺序存储 顺序表的定义​ 顺序存储的线性表，用一组地址连续的存储单元依次存放线性表中各个数据元素的存储结构。 顺序表的地址计算​ 假设一个元素占c个存储单元，第i个数据元素的地址为：Loc(a0)+i x c 顺序表特点 逻辑上相邻的元素，物理位置也是相邻的 存储密度高，需要预先分配足够的存储空间，空间浪费 便于随机存取 不便于插入和删除，有大量的数据移动 顺序表操作的实现public class SqList implements iList{ private Object[] listElem; private int len; //顺序表的构造函数，构造一个存储空间为maxSize的线性表 public SqList(int maxSize){ len = 0; listElem = new Object[maxSize]; } public void clear(){ len = 0; } public boolean isEmpty(){ return len == 0; } }排序排序的分类： 内排序：待排序序列完全存放在内存中进行的排序过程，适合数量不太大的数据元素的排序 外排序：待排序的数据元素非常多，以至于它们必须存储在外部存储器上内排序插入排序方法大致分为以下几种类型：插入、交换、选择、归并和其他 插入类排序方法是指将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序序列的长度 交换类排序方法是通过交换无序序列中的记录，从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中。 选择类排序从记录的无序子序列中选择关键字最小或最大的记录。 归并类通过归并两个或两个以上的记录有序子序列。 排序算法 平均 最好 最坏 空间复杂度 稳定性 直接插入 O(n2) O(n) O(n2) O(1) 稳定 冒泡 O(n2) O(n2) O(n2) O(1) 稳定 快速 O(nlog2n) O(nlog2n) O(n2) O(log2n) 不稳定 直接选择 O(n2) O(n2) O(n2) O(1) 不稳定 堆 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 归并 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 插入排序直接插入排序​ 基本思想：每趟将一条待排序的记录，按其关键字值的大小插入到前面已经排序好的序列中适当的位置，直到全部记录插入完成为止。直接插入排序过程如下图所示：​ public static void insertSort(int[] nums){ int len = nums.length; if(len &amp;lt;=1){ return; } int i,j; for(i = 1;i&amp;lt;len;i++){ int tmp = nums[i]; for(j = i-1;j&amp;gt;=0&amp;amp;&amp;amp; nums[j]&amp;gt; tmp;j--){ nums[j+1] = nums[j]; } nums[j+1] = tmp; }}算法性能分析 空间复杂度​ 仅用了一个辅助单元，空间复杂度为O(1) 时间复杂度​ 逐个插入记录的操作进行了n-1趟，最坏的比较次数为$\\frac{1}{2}n(n-1)$，总的移动次数为$\\frac{1}{2}n(n-1)+2n$。平均比较和移动次数为$\\frac{1}{4}n(n-1)$，时间复杂度为O(n2)。 算法稳定性：稳定交换排序冒泡排序​ 基本思想：将待排序的数组看成从上到下排放，把关键字值较小的记录看成“较轻的”，关键字值较大的记录看成“较重的”。 public static void bubbleSort(int[] nums){ int len = nums.length; int tmp; boolean flag; for(int i=0;i&amp;lt;len-1;i++){ flag=false; for(int j=len-1;j&amp;gt;i;j--){ if(nums[j-1]&amp;gt;nums[j]){ tmp = nums[j]; nums[j] = nums[j-1]; nums[j-1] = tmp; flag = true; } } if(flag== false){ return; } } }算法性能1.空间复杂度 O(1)2.时间复杂度O(n2)3.算法稳定性：稳定快速排序​ 基本思想：通过一趟排序要将排序的记录分割成独立的两个部分，其中一个部分的所有记录的关键字值比另外一部分所有的关键字值小，然后按此方法对两部分分别快速排序，递归进行。步骤 设置两个变量i，j，初始值分别为low和high，分别表示待排序序列的起始下标和终止下标。 将第i个记录暂存在变量pivot中 从下标为j 的位置开始由后向前一次搜索，当找到第一个比pivot的关键字值小的记录时，则将该记录前移到i位置，i=i+1 从i向后搜索，找到第一个比pivot大的，后移到j位置，j=j-1 重复3-4 直到i==j i位置的值为pivot public static void quickSort(int[] nums,int low,int high){ if(low &amp;lt; high){ int pivot = Partition(nums,low,high); quickSort(nums,low,pivot-1); quickSort(nums,pivot+1,high); } } public static int Partition(int[] nums,int low,int high){ int pivot = nums[low]; while(low &amp;lt;high){ while(low &amp;lt;high &amp;amp;&amp;amp; nums[high]&amp;gt;=pivot){ high--; } nums[low] = nums[high]; while(low &amp;lt;high &amp;amp;&amp;amp; nums[low]&amp;lt;=pivot){ low++; } nums[high] = nums[low]; } nums[low] = pivot; return low; }算法性能分析 空间复杂度：需要一个栈来递归实现，每层递归调用的指针与参数用栈存放。最好和平均情况O(log2n)，最坏情况O(n) 时间复杂度​ 最好和平均情况下O(nlog2n)。最坏情况下O(n2) 算法稳定性：不稳定选择排序直接选择排序基本思想：在第一趟中，从n个记录中找出关键字值最小的记录与第一个记录交换，以此类推。 public static void selectSort(int[] nums){ int len = nums.length; int i,j,min; for(i=0;i&amp;lt;len-1;i++){ min = i; for(j=i+1;j&amp;lt;len;j++){ if(nums[j]&amp;lt;nums[min]){ min = j; } } if(min != i){ int tmp = nums[min]; nums[min] =nums[i]; nums[i] = tmp; } } }算法性能分析1.空间复杂度 O(1)2.时间复杂度 O(n2)3.算法稳定性：不稳定堆排序 堆的定义​ 有n个记录关键字的序列，大顶堆和小顶堆。采用一个数组存储序列，该序列可以看作是一棵顺序存储的完全二叉树。以大顶堆为例，堆顶记录的关键字值最大，下图是初始序列{53,17,78,09,45,65,87,32}调整为大顶堆的过程归并排序" }, { "title": "LRU缓存", "url": "/posts/LRU%E7%BC%93%E5%AD%98/", "categories": "算法", "tags": "技术", "date": "2022-04-02 04:16:00 +0000", "snippet": "package com.Seejen.java;import java.util.HashMap;import java.util.Map;//最简单的数据结构就是双向链表 LinkedHashMap，面试的时候最好手写定义一个双向链表public class Main { public static void main(String[] args) { LRUCache obj = new LRUCache(10); obj.put(1,1); System.out.println(obj.get(1)); }}class LRUCache{ private Map&amp;lt;Integer,DLinkedNode&amp;gt; cache = new HashMap&amp;lt;&amp;gt;(); private int size; private int capacity; private DLinkedNode head,tail; public LRUCache(int capacity){ this.size = 0; this.capacity = capacity; head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev = head; } public int get(int key){ DLinkedNode node = cache.get(key); if(node == null){ return -1; } moveToHead(node); return node.val; } public void put(int key,int val){ DLinkedNode node = cache.get(key); if(node == null){ DLinkedNode newNode = new DLinkedNode(key,val); cache.put(key,newNode); addToHead(newNode); size++; if(size &amp;gt; capacity){ DLinkedNode tail = removeTail(); cache.remove(tail.key); size--; } } else{ node.val = val; moveToHead(node); } } private void addToHead(DLinkedNode node){ node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; } private void removeNode(DLinkedNode node){ node.prev.next = node.next; node.next.prev = node.prev; } private void moveToHead(DLinkedNode node) { removeNode(node); addToHead(node); } private DLinkedNode removeTail(){ DLinkedNode res = tail.prev; removeNode(res); return res; }}class DLinkedNode{ int key; int val; DLinkedNode prev; DLinkedNode next; public DLinkedNode(){} public DLinkedNode(int key,int val){ this.key = key; this.val = val; }}" }, { "title": "Java基础2", "url": "/posts/Java%E5%9F%BA%E7%A1%802/", "categories": "Java", "tags": "技术", "date": "2022-04-01 04:16:00 +0000", "snippet": "Java基础2数据类型相关包装类型​ 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成Integer x = 2; // 装箱 调用了 Integer.valueOf(2)int y = x; // 拆箱 调用了 X.intValue()缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // truevalueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。public static Integer valueOf(int i) { if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);}在 Java 8 中，Integer 缓存池的大小默认为 -128~127。static final int low = -128;static final int high;static final Integer cache[];static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &amp;lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &amp;gt;= 127;}编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。Integer m = 123;Integer n = 123;System.out.println(m == n); // true基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。String在 Java 8 中，String 内部使用 char 数组存储数据。public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage. */ private final char value[];}在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in {@code value}. */ private final byte coder;}String不可变的原因value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。不可变的好处1.可以缓存hash值因为String的hash值经常被使用，力例如String用作HashMap的key。不可变的特性可以使得hash值也不可变，因此只需要进行一次计算。2.String Pool的需要如果一个String对象已经被创建了，那么就会从String Pool中取得引用。只有String是不可变的，才可能使用字符串常量池。3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String、StringBuffer和StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步new String 创建对象的问题字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s2.intern();System.out.println(s3 == s4); // true如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。String s5 = &quot;bbb&quot;;String s6 = &quot;bbb&quot;;System.out.println(s5 == s6); // true在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。public class NewStringTest { public static void main(String[] args) { String s = new String(&quot;abc&quot;); }}使用 javap -verbose 进行反编译，得到以下内容：// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.&quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;)V 9: astore_1// ...在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。public String(String original) { this.value = original.value; this.hash = original.hash;}面向对象(OOP)​ 面向过程 步骤清晰简单，第一步、第二步… 面向过程适合处理一些简单问题​ 面向对象 物以类聚，分类的思维模式，先思考解决问题需要哪些分类，然后对分类进行单独思考，最后对某个分类的细节进行面向过程的思索。 适合处理复杂的问题、需要多人协作的问题。什么是面向对象本质就是：以类的方式组织代码，以对象的组织封装数据抽象三大特性： 封装​ 从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对外提供调用的接口。 继承​ 不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 多态​ 多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。用户自定义类​ 编写复杂的应用程序需要很多主力类，通常这些类都没有main方法，但是有自己的实例字段和实例方法。想要构建一个完整的程序，会结合使用多个类，其中只有一个类有main方法。简单示例下面是一个自定义的二叉树类：class TreeNode{ int val; TreeNode left; TreeNode right; TreeNode(){} TreeNode(int val){ this.val = val; } TreeNode(int val,TreeNode left,TreeNode right){ this.val = val; this.left=left; this.right=right; } @Override public String toString() { return &quot;TreeNode{&quot; + &quot;val=&quot; + val + &quot;, left=&quot; + left + &quot;, right=&quot; + right + &#39;}&#39;; }}访问权限修饰符 修饰符类型 当前类 子类 当前包 其他包 public ☑️ ☑️ ☑️ ☑️ protected ☑️ ☑️ ☑️   private ☑️       使用null引用​ 如果对null值应用一个方法，会产生一个NullPointerException异常。LocalDtae birthday = null;String s = birthday.toString();//NullPointerExceptionfinal实例字段​ 可以将实例字段定义为final。这样的字段必须在构造对象时初始化。确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段。​ final修饰符对于类型为基本类型或者不可变类的字段有用。（如果类中的所有方法都不会改变其对象，这样的类就是不可变的类，eg：String类）。​ 对与可变的类，使用final修饰符可能会造成混乱。 private fianl StringBuffer evaluations; evaluations = new StringBuffer();final关键字知识表示存储在evaluations变量中的对象引用不会再指向另一个不同的StringBuffer对象，不过这个对象可以更改。静态字段与静态方法静态字段​ 使用static关键字修饰的字段，每个类只有一个这样的字段，只属于类，而不属于任何单个对象。对于非静态的实例字段，每个对象都有自己的一个副本。一般会使用静态常量。例如：static final double PI = 3.14静态方法​ 静态方法是不在对象上执行的方法。例如：Math类的方法，都是静态方法。静态方法的调用使用（类名.方法名）。静态方法的使用场景： 方法不需要访问对象的状态，因为它所需要的所有参数都通过显式参数提供。 方法只需要访问类的静态字段。静态语句块静态语句块在类初始化时运行一次public class A { static { System.out.println(&quot;123&quot;); } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); }}静态内部类非静态初始化顺序​ 存在继承的情况下，初始化顺序为 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数）工厂方法​ 静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。NumberFormat类生成不同风格的格式化对象如下：NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();NumberFormat perrcentFormatter = NumberFormat.getPercentInstance();double x = 0.1;System.out.println(currencyFormatter.format(x));System.out.println(percentFormatter.format(x));不利用NumberFormat类构造器完成这些操作的原因： 无法命名构造器。构造器的名字必须与类名相同。但是，这里希望有两个不同名字，分别得到货币实例和百分比实例。 使用构造器时，无法改变所构造对象的类型。而工厂方法实际上将返回DecimalFormat类的对象，这是NumberFormat 的一个子类。继承类、超类和子类​重载​ 如果多个方法有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法。匹配不到，会产生编译时错误。​ 注：返回类型不是方法签名的一部分，不能有两个名字相同、参数类型也相同却有不同返回值类型的方法异常​ Java语言将派生于Error和RuntimException类的所有异常称为非检查型异常。Unchecked Exception Error​ 描述了Java运行时系统的内部错误和资源耗尽错误。 RuntimeException​ 一般规则是：由编程错误导致的异常属于RuntimeException 错误的强制类型转换 数组访问越界 访问null指针在Java代码编译过程中，即使不处理不受检查异常也可以正常通过编译。Checked Exception I/OException 试图超越文件末尾继续读区数据 试图打开一个不存在的文件 试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在在Java代码的编译过程中，如股票受检查异常没有被catch/throws处理的话，就没办法通过编译。" }, { "title": "数据库相关知识", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/", "categories": "数据库", "tags": "技术", "date": "2022-03-31 15:20:00 +0000", "snippet": "数据库相关知识索引如何解决幻读 将数据库隔离级别改成可串行化。（很少使用，性能问题） 在Mysql默认隔离级别可重复读下，使用MVCC+Next Key Locks分两种情况快照读（MVCC 不存在幻读的问题）​ 在快照读的情况下，MVCC（多版本并发控制），主要是：事务版本号、表的隐藏列、undo log、read view。 事务版本号​ 每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。 表的隐藏列​ DB_TRX_ID:记录操作该数据的事务的ID​ DB_ROLL_PTR: 指向上一个版本数据在undo log里的位置指针​ DB_ROW_ID:隐藏ID，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引 Undo log​ 记录数据被修改之前的日志，在表信息修改之前会把数据拷贝到undo log里，当事务进行回滚时可以进行数据还原。作用 保证事务的原子性和一致性，当事务进行回滚时可以用undo log进行恢复 用于快照读的数据 Read View​ trx_ids:当前系统活跃（未提交）的事务版本号集合​ low_limit_id:创建read view时最大版本号+1​ up_limit_id:创建read view时活跃事务的最小版本号​ creator_trx_id:创建当前read view的事务版本号Read View 匹配条件 数据事务ID&amp;lt;up_limit_id则显示​ 表明数据在当前事务之前就已经存在，可以显示 数据事务ID&amp;gt;= low_limit_id不显示​ 表明数据是在read view创建之后才产生的，不显示 Up_limit_id &amp;lt;=数据事务ID&amp;lt;=low_limit_id 与trx_ids匹配 不存在trx_ids中，说明read view产生的时候，事务已经提交，可以显示 在集合中，说明事务还没有提交，如果数据事务ID等于creator_trx_id说明这个数据时当前事务自己产生的，可以显示。 否则，未提交并且不是当前事务，不显示。 不满足read view时，从undo log获取数据当前读​ 当前读的情况有：执行select … for update /lock in share mode、insert、update、delete等。​ MVCC不能解决当前读情况下的幻读，因为每次读取的都是最新的数据。此时需要借助Next Key Locks例如表中的索引为2 3 8 9 10 14 15 16，当前读索引在3-8之间的，会将当前区间锁住，并且下一个区间9-10也会锁住，另一个事务不能在当前的这些位置进行插入，如果要插入就等待，当前事务可以进行插入。" }, { "title": "Java基础1", "url": "/posts/Java%E5%9F%BA%E7%A1%801/", "categories": "Java", "tags": "技术", "date": "2022-03-30 04:16:00 +0000", "snippet": "Java的基本特性 优势 简单性 面向对象 可移植性 高性能 分布式 多线程 安全性​ ……Java的三大版本JavaSE 标准版（桌面程序、控制台开发……）JavaEE 企业级开发（Web端 、服务器开发……）JavaME 嵌入式开发(手机、小家电 ……知道有这么个东西就行，基本不用了)JRE 、JDK、 JVMJDK：JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。JRE： JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。JVM: Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。注释单行注释 //多行注释 /* */文档注释 /** */Java中的数据类型Java是一种强类型语言：变量的使用要严格符合规定，所有变量必须先定义后使用。Java 的数据类型分为两大类： 基本类型 引用类型基本类型​ Java中一共有8种基本类型： 整型 类型 存储需求（字节） 取值范围 byte 1 -128~127 short 2 -215~215-1 int 4 -231~231-1 long 8 -263~263-1 浮点型 类型 存储需求（字节） float 4 double 8 char类型2个字节 char类型的字面量要用单引号括起来 boolean类型只有两个值 false 和true引用类型​ 类、接口、数组。（后面详细介绍）常见的一些问题 进制的问题public class Main{ public static void main(Stirng args[]){ int a = 10;//十进制 10 int b = 010;//八进制 8 int c = 0x10;//十六进制 16 0-9，A-F //二进制0b //浮点数的问题 //具体的业务场景 银行业务 float double 会存在问题 float f = 0.1f; double d = 1.0/10; System.out.println(f==d); // false //应该用BigDecimal类，去处理浮点数的运算。避免误差 }}//编码相关//Unicode编码 两个字节char c = &#39;\\u0061&#39;;//a变量与常量1. 声明变量​ 每个变量都有一个类型（type），在声明变量之前，先指定变量的类型，然后是变量名。eg:double salary; 大小写敏感2. 变量初始化​ 声明变量后必须用赋值语句对变量进行显式初始化，未初始化的变量会被Java编译器认为是错误的。（变量的声明尽量靠近该变量第一次使用的地方）注：从Java10开始，对于局部变量，如果可以从初始值推断出类型，就不需要声明类型，用关键字varvar days = 12;3. 常量​ 在Java中，使用关键字final指示常量，表示这个变量只能被赋值一次。一旦被赋值就不可再改变。常量名全部大写。 枚举类型（浅谈，后面会详细讲解）​ 变量的取值只在一个有限的集合内。例如服装的尺寸只有S、M、L、X。但是在编程中使用变量保存可能是一个错误的值。使用枚举类型，包含有限个命名的值。enum Size {SMALL,MEDIUM,LARGE,EXTRA_LARGE};Size s = Size.MEDIUM;//Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值4. 作用域​ 类变量：使用static修饰。​ 实例变量：不使用static修饰。方法外，类中，从属于对象。​ 局部变量：方法或代码块中定义的变量。使用之前必须声明，初始化值。运算符1. 数值类型之间的转换​ ​ 6个实线箭头表示无信息丢失的转换，三个虚线箭头表示可能有精度损失的转换。​ 例如123456789是一个大整数，它所包含的位数比float类型所能表示的位数多。转换为float时，将会得到正确的大小，但是会损失精度。int n = 123456789;float f = n;//f is 1.23456792E8​ 当使用二元运算符连接两个值时（eg：n+f，n为整数，f为浮点数），先要将两个数转换为同一种类型，然后计算。（优先级从上到下） 有一个是double-&amp;gt;double 有一个float-&amp;gt;float 有一个类型为long-&amp;gt;long 否则为intpublic class Main { public static void main(String[] args) { long a = 1; float b = 1.1f; Object c = a+b; System.out.println(c.getClass().toString()); //class java.lang.Float }}​ 2. 强制类型转换​ 在必要的时候，int类型会自动转换为double类型，但是有时候也需要将double转换为int类型。在Java中允许这种数值之间的类型转换，即：强制类型转换。 精度问题 截断小数点double x = 9.997;int nx = (int)x;//nx=9; 有舍入double x = 9.997;int nx = (int)Math.round(x);//nx=10; 内存溢出问题int i = 128;byte b = (byte)i;//会转换成一个完全不同的数据3. 位运算 位元算 &amp;amp;与、｜或、^ 、~， &amp;amp;&amp;amp;   采用短路的方式，即得到结果时不一定两个操作数都要计算。 « 和» 左移和右移操作。包机制与Java Doc包​ 包，解决文件重名的问题。包的命名规范，一般使用公司域名倒置作为包名，eg：com.baidu.wwwJava Doc​ Java Doc是用来生成自己的API文档的。 参数 author：作者 version：版本号 since：需要最早使用的jdk版本 param：参数 return：返回值情况 throws：异常抛出情况/** *@author *@version *@since */public class Main{ String name; /** *@parma *@return */ public String test(String name){ return name; }} 生成doc文档javadoc -encoding UTF-8 -charset UTF-8 Main.java流程控制Switch​ 一种多选择的实现 方式 switch case 语句。​ 判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。switch语句中的变量类型可以是： byte、short、int或者char 从Java SE 7 开始 switch支持字符串String类型，同时case标签必须为字符串常量或字面量。public class Main { public static void main(String[] args) { char grade = &#39;C&#39;; switch (grade){ case &#39;A&#39;: System.out.println(&quot;优秀&quot;); break; case &#39;B&#39;: System.out.println(); default: System.out.println(); } }}注：每一句case写完，都要加上break支持字符串String类型package com.Seejen.java;public class Main { public static void main(String[] args) { String name = &quot;Seejen&quot;; switch (name){ case &quot;Seejen&quot;: System.out.println(&quot;Seejen&quot;); break; case &quot;Ycc&quot;: System.out.println(&quot;Ycc&quot;); break; default: System.out.println(&quot;No Person&quot;); } }}能够支持String类型的底层原理 查看反编译之后的class文件，其实是通过hashCode()方法和equals()方法来比较。//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.Seejen.java;public class Main { public Main() { } public static void main(String[] args) { String name = &quot;Seejen&quot;; byte var3 = -1; switch(name.hashCode()) { case -1822358144: if (name.equals(&quot;Seejen&quot;)) { var3 = 0; } break; case 88697: if (name.equals(&quot;Ycc&quot;)) { var3 = 1; } } switch(var3) { case 0: System.out.println(&quot;Seejen&quot;); break; case 1: System.out.println(&quot;Ycc&quot;); break; default: System.out.println(&quot;No Person&quot;); } }}Do…While​ 对于while而言，如果不满足条件就不能进入循环，但有时后需要在不满足条件的情况下，最少要执行一次。e   while do…while 判断顺序 先判断后执行 先执行后判断 执行次数 &amp;gt;=0 &amp;gt;=1 For循环增强for循环（遍历数组，集合） Java5引入了一种主要用于数组或集合的增强型for循环 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配/作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者返回值为数组的方法。package com.Seejen.java;public class Main { public static void main(String[] args) { int[] nums = new int[]{1,4,6,20}; for (int num : nums) { System.out.println(nums); } }}方法Java方法时语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用设计方法的原则：方法的本意是功能块，我们实现方法的时候，最好保持方法的原子性，一个方法只完成一个功能，这样有利于后期的扩展方法包含一个方法头和一个方法体 修饰符：可选 返回值类型： 方法名 参数类型：形参、实参 方法体方法的调用对象名.方法名静态方法：类名.方法名值传递和引用传递程序设计语言将实参传递给方法（或函数）的方式分为两种： 值传递 ：方法接收的是实参值的拷贝，会创建副本。 引用传递 ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。重载重载就是在一个类中，有相同的函数名称，但是形参不同的函数。规则 方法名必须相同 参数列表必须不同（个数、类型、顺序） 返回类型可以相同也可以不同 仅仅返回类型不同不足以成为方法的重载eg：构造方法可变参数 JDK1.5开始，Java支持传递同类型的可变参数 在方法声明中，制定参数类型后加一个… 一个方法中只能有一个可变参数，并且必须是方法的最后一个参数，任何的普通参数必须在之前声明数组数组工具类Arrays方法 toString() sort() fill()" } ]
